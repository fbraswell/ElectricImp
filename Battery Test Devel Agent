// Agent code for Data Test
server.log("---AGENT START---");
const XIVELY_URL = "https://api.xively.com/v2/feeds/";  // Xively base URL
const XIVELY_Account_Authorization = "Basic a25pZ2h0aGF3azprbmlnM3QzOHdr"; // WellMark knighthawk auth
const PUMP_MODE = 1;
const TRANSDUCER_MODE = 0; 

// myDevID <- "no Imp dev id yet";
IMP_DEV_ID <- "no Imp dev id yet";
XIVELY_FEED <- 0;   // Xively feed # will go here
XIVELY_FEED_NAME <- "xively feed name"; // Xively Feed Name
XIVELY_API_ENDPOINT <- "no Xively endpoint yet";
// agent_myapikey <- "no Xively feed key yet";
XIVELY_API_KEY <- "no Xively feed key yet";

const MB_ONTIME = "MB_OnTime";
const MB_OFFTIME = "MB_OffTime";
const MB_TEMPSETPOINT = "MB_TempSetPoint";
const MB_QUARTSPERDAY = "MB_QuartsPerDay";
const MB_CYCLES = "MB_Cycles";
const MB_TEMPERATURE = "MB_Temperature";
const MB_PLUNGERSIZE = "MB_PlungerSize";
const MB_PINPOSITION = "MB_PinPosition";
const MB_MOTORSIZE = "MB_MotorSize";
const MB_BATTERYVOLTAGE = "MB_BatteryVoltage";
const MB_VERSIONNUMBER = "MB_VersionNumber";

TimeMark <- 
{
    MB_OnTime = -1,
    MB_OffTime = -1,
    MB_TempSetPoint = -1,
    MB_QuartsPerDay = -1,
    MB_Cycles = -1,
    MB_Temperature = -1,
    MB_PlungerSize = -1,
    MB_PinPosition = -1,
    MB_MotorSize = -1,
    MB_BatteryVoltage = -1,
    MB_VersionNumber = -1
}

const PT500_MODEL = "PT500_model";
const PT500_PRESSURE_H2O = "PT500_pressure_h2o";
const PT500_TEMPC = "PT500_tempC";
const PT500_CALC = "PT500_calc";
const PT500_BATV = "PT500_batv";

PT500 <- 
{
    PT500_model = -1,
    PT500_pressure_h2o = -1,
    PT500_tempC = -1,
    PT500_calc = -1,
    PT500_batv = -1
}

const MPX_MODEL = "MPX_model";
const MPX_TOPDIST = "MPX_topdist";
const MPX_BOTDIST = "MPX_botdist";
const MPX_TEMPC = "MPX_tempC"
const MPX_TOPCALC = "MPX_topcalc";
const MPX_BOTCALC = "MPX_botcalc";

MPX <-
{
    MPX_model = -1,
    MPX_topdist = -1,
    MPX_botdist = -1,
    MPX_tempC = -1,
    MPX_topcalc = -1,
    MPX_botcalc = -1
}

const ICHEM_ = "ichem";
ICHEM <-
{
    ICHEM = -1,
}

// Defaults
IMP_SAMPLE_PER <- 10; // Default 10 sec sample period
IMP_XMIT_PER <- 60; // Default 60 sec transmit period
// IMP_MODE <- TRANSDUCER_MODE; // Mode 0 = transducer only; Mode 1 = Pump
IMP_MODE <- PUMP_MODE; // Mode 0 = transducer only; Mode 1 = Pump

// Default trigger points
// If a trigger is exceeded, the Imp reports the event immediately
// Immediate means the Imp reports on the next sample period, not waiting for
// the scheduled xmit time.
// More data channels will be added as needed
IMP_ANALOG1_THRESHOLD <- -1; // trigger threshold
IMP_ANALOG1_RANGE <- 0.1; // hysteresis range - 1/2 above, 1/2 below threshsold

// IMP_DEV_ID  = strip(xivelyInfo[0]);
const X_IMP_DEV_ID = 0;
const X_XIVELY_FEED_NAME = 1;
const X_XIVELY_FEED = 2;
const X_XIVELY_API_KEY = 3;
const X_IMP_SAMPLE_PER = 4;
const X_IMP_XMIT_PER = 5;
const X_IMP_MODE = 6;
const X_IMP_ANALOG1_THRESHOLD = 7;
const X_IMP_ANALOG1_RANGE = 8;

// Imp Wake Codes

impWakeCodes <-
[
//    Code    Description
     "The power was turned on", // 0
     "A software reset took place", // 1
     "An event timer fired", // 2
    "Pulse detected on Wakeup Pin", // 3
    "New Squirrel code downloaded", // 4
    "Squirrel runtime error", // 5
    "impOS update", // 6
    "A snooze-and-retry event", // 7
        // imp003 only
    "Hardware reset", // 8
];

/*
TimeMark <- 
{
    MB_ONTIME = -1,
    MB_OFFTIME = -1,
    MB_TEMPSETPOINT = -1,
    MB_QUARTSPERDAY = -1,
    MB_CYCLES = -1,
    MB_TEMPERATURE = -1,
    MB_PLUNGERSIZE = -1,
    MB_PINPOSITION = -1,
    MB_MOTORSIZE = -1,
    MB_BATTERYVOLTAGE = -1,
    MB_VERSIONNUMBER = -1
}

const MB_ONTIME = "MB_OnTime";
const MB_OFFTIME = "MB_OffTime";
const MB_TEMPSETPOINT = "MB_TempSetPoint";
const MB_QUARTSPERDAY = "MB_QuartsPerDay";
const MB_CYCLES = "MB_Cycles";
const MB_TEMPERATURE = "MB_Temperature";
const MB_PLUNGERSIZE = "MB_PlungerSize";
const MB_PINPOSITION = "MB_PinPosition";
const MB_MOTORSIZE = "MB_MotorSize";
const MB_BATTERYVOLTAGE = "MB_BatteryVoltage";
const MB_VERSIONNUMBER = "MB_VersionNumber";
*/

const TIME_MARK_JAN14 = "time_mark_jan14";
device.on(TIME_MARK_JAN14, function(a)
{
//    foreach (key, val in data)
//        {
//            server.log("Time Mark key: "+key+" val: "+val)
//        }
        
    TimeMark.MB_OnTime <- (a[3] << 8) | a[4];
    TimeMark.MB_OffTime <- (a[5] << 8) | a[6]; 
    TimeMark.MB_TempSetPoint <- (a[7] << 8) | a[8];
    
    // Convert the quarts per day from binary to a float
        local qpd = blob(4);
        qpd.writen(a[12], 'b');
        qpd.writen(a[11], 'b');
        qpd.writen(a[10], 'b');
        qpd.writen(a[9], 'b');
        qpd.seek(0, 'b');
        local quartsPerDay = qpd.readn('f');
    
 //   TimeMark.MB_QUARTSPERDAY <- quartsPerDay;
    TimeMark.MB_QuartsPerDay <- quartsPerDay;
    TimeMark.MB_Cycles <- (a[13] << 24) | (a[14] << 16) | (a[15] << 8) | a[16];
    TimeMark.MB_Temperature <- (a[17] << 8) | a[18];
    TimeMark.MB_PlungerSize <- (a[19] << 8) | a[20];
    TimeMark.MB_PinPosition <- (a[21] << 8) | a[22];
    TimeMark.MB_MotorSize <- (a[23] << 8) | a[24];
    TimeMark.MB_BatteryVoltage <- casti2f((a[25] << 24) | (a[26] << 16) | (a[27] << 8) | a[28]); // not working
    TimeMark.MB_VersionNumber <- (a[29] << 24) | (a[30] << 16) | (a[31] << 8) | a[32];
    
//    foreach (key, val in TimeMark)
//        {
//            server.log("Time Mark key: "+key+" val: "+val)
//        }
        
} // end of function(data)
); // end device.on(TIME_MARK_JAN14, function(data)

const MB_PT500_HREG = "MB_PT500_HREG";
device.on(MB_PT500_HREG, function(data)
{
    foreach (key, val in data)
        {
            server.log("APG PT-500 hreg key: "+key+" val: "+val)
        }
} // end of function(data)
); // end device.on(MB_PT500_HREG, function(data)

const MB_PT500_IREG = "MB_PT500_IREG";
device.on(MB_PT500_IREG, function(data)
{
//    foreach (key, val in data)
//        {
//            server.log("APG PT-500 ireg key: "+key+" val: "+val)
//        }
    // Decode registers
    PT500.PT500_model <- (data[3] << 8) | data[4];
    PT500.PT500_pressure_h2o <- (data[5] << 8) | data[6];
    PT500.PT500_tempC <- (data[9] << 8) | data[10];
    PT500.PT500_calc <- (data[13] << 8) | data[14];
    PT500.PT500_batv <- (data[21] << 8) | data[22];
//    foreach (key, val in PT500)
//    {
//        server.log("APG PT-500: "+key+": "+val);
//    }
    
} // end of function(data)
); // end device.on(MB_PT500_IREG, function(data)

const MB_MPX_IREG = "MB_MPX_IREG";
device.on(MB_MPX_IREG, function(data)
{
//    foreach (key, val in data)
//        {
//            server.log("APG MPX ireg key: "+key+" val: "+val)
//        }
    // Decode registers
    MPX.MPX_model <- (data[3] << 8) | data[4];
    MPX.MPX_topdist <- (data[5] << 8) | data[6];
    MPX.MPX_botdist <- (data[7] << 8) | data[8];
    MPX.MPX_tempC <- (data[9] << 8) | data[10];
    MPX.MPX_topcalc <- (data[11] << 24) | (data[12] << 16) | (data[13] << 8) | data[14];
    MPX.MPX_botcalc <- (data[15] << 24) | (data[16] << 16) | (data[17] << 8) | data[18];
//    foreach (key, val in PT500)
//    {
//        server.log("APG MPX: "+key+": "+val);
//    }
    
} // end of function(data)
); // end device.on(MB_MPX_IREG, function(data)

// Get meta data from the device, which includes the
// impID and ssid information

//  meta key: ssid val: FrankBraswellsPhone5s
//  meta key: devid val: 235c87eb6e4936ee
device.on("metadata", function(data)
    {

        foreach (key, val in data)
        {
            server.log("meta key: "+key+" val: "+val);
        }

        // stash the imp ID for later use
        IMP_DEV_ID <- data.devid; 
        IMP_SSID <- data.ssid;
        getXivelyFeedsTable();
    }
);  // device.on("metadata", function(data)

// Get table data from device and form a csv file
device.on("tabledata",function(data)
    {
    //  First make sure that IMP_DEV_ID is defined
    //  If not, get the information from the Imp
    // This situation can happen during development when
    // the agent code is updated, but the device code
    // doesn't change    
    if(IMP_DEV_ID == "no Imp dev id yet")
    {
        server.log("Don't have Imp dev id");
        local obj = 0;
        // See if I can catch it here - Imp must not be sleeping
//        device.send("getImpInfo", obj);  // Request Information
        device.onconnect(function() 
        {
            device.send("getImpInfo", obj);  // Request Information
            server.log("Request Imp dev id"); 
        });
        return;
    } else
    {
        // Since device.onconnect stays active and executes with
        // each connect, it is necessary to reset it at disconnect time.
        // At disconnect time, turn off the device.onconnect procedure
        // so the device.send("getImpInfo", obj) doesn't keep running
        device.ondisconnect(function()
        {
            device.onconnect(function(){});
        });
    }    
        
        local makecsv = ""; // used to build csv file for Xively
        local report_MB = ""; // MB for log report decoded by device
        local report_MB_agent = ""; // MB info decoded by agent
        local report_PT500_agent = ""; // PT500 info decoded by agent
        local report_MPX_agent = ""; // MPX info decoded by agent
        local report_pvoltest = ""; // for log report
        local report_data = "";  // for log report
        local keys = [ ];
        local bootcount = data.bootcount;
        foreach (key, val in data)
        {
            keys.push(key);
        }
        // sorting the keys makes the list easier to read
        keys.sort();
//        server.log("++++++++keys length: "+keys.len());
//        foreach (key, val in data)
        foreach (key in keys)
        {
//            server.log("+++++ key: "+key);
            local val = data[key];
            // Catching keys longer than 9!!!!! They are the pvoltest time string
            if(key.len() > 9 && (key.find("MB") == null 
                            && key.find("PT500") == null
                            && key.find("MPX") == null )) // time stamp string is longer than the other keys
            {
                // Catch pvoltest data here
                    // build time string
                local v = key.tointeger() - data["time"];
                local t = date(key.tointeger());
                local tformat = format("%4d-%02d-%02dT%02d:%02d:%02d", 
                                        t.year, t.month + 1, t.day, t.hour, t.min, t.sec);
// debug               server.log("table key: "+key+", val: "+val+" - time diff: "+v+" time: "+tformat);
                    // build csv entry with name of chan, time, data value
                makecsv += "pvolttest, "+tformat+", "+val+"\n";
                    // list of pvoltest info
                report_pvoltest += "pvolttest, "+tformat+", "+val+"\n";
            } else
            {
                // Catch MB and other data here
//                server.log("table key: "+key+", val: "+val);
                    // build csv entry with name of chan, data value
                makecsv += key+", "+val+"\n";
                
                
                // Locate Modbus data
                if (key.find("MB") != null ||
                    key.find("PT500") != null ||
                    key.find("MPX") != null)
                {   
                    
                    // list of MB info
                    // put MB info in report_MB string
                    report_MB += key+", "+val+"\n";
                    
                    if(key.find("MB") != null)
                    {
                        if ( bootcount != 0 &&
                            (key == "MB_Cycles" || 
                             key == "MB_QuartsPerDay" || 
                             key == "MB_Temperature" ))
                        {   
                        // only save these three
                            report_MB_agent += key+", "+TimeMark[key]+"\n";
                        } else
                        {
                        // save all if bootcount == 0
                            report_MB_agent += key+", "+TimeMark[key]+"\n";
                        }
                    } // key.find("MB") != null
/*                    
PT500 <- 
{
    PT500_MODEL = -1, once
    PT500_PRESSURE_H2O = -1, each time
    PT500_TEMPC = -1, each time
    PT500_CALC = -1, never
    PT500_BATV = -1 once
}                    
*/                    // PT-500 info
                    // Put info into report_PT500_agent
                    if(key.find("PT500") != null)
                    {
                        if ( bootcount != 0 &&
                           (key == "PT500_PRESSURE_H2O" ||
                            key == "PT500_TEMPC"))
                        {
                            report_PT500_agent += key+", "+PT500[key]+"\n";
                        } else
                        {
                        // save all if bootcount == 0
                            report_PT500_agent += key+", "+PT500[key]+"\n";
                        }
                    } // key.find("PT500") != null 
/*
MPX <-
{
    MPX_model = -1, one time
    MPX_topdist = -1, each time
    MPX_botdist = -1, each time
    MPX_tempC = -1, each time
    MPX_topcalc = -1, one time
    MPX_botcalc = -1 one time
}
*/
                    // Put info into report_MPX_agent
                    if(key.find("MPX") != null)
                    {
                        if ( bootcount != 0 &&
                           (key == "MPX_topdist" ||
                            key == "MPX_botdist" ||
                            key == "MPX_tempC"))
                        {
                            report_MPX_agent += key+", "+MPX[key]+"\n";
                        } else
                        {
                        // save all if bootcount == 0
                            report_MPX_agent += key+", "+MPX[key]+"\n";
                        }
                    } // key.find("MPX") != null 
                    
                } else
                {   // list of other data
                    // place other data in report_data string
                    if (key.find("wakewhy") != null)
                    {   // wakewhy is a numeric code 1 - 8
                        // look up the string in the table
                        val = val + ": " + impWakeCodes[val];
                    }
                    report_data += key+", "+val+"\n";
                }
            }
        } // foreach (key in keys)
        
        // Report values to the log
        if(report_pvoltest.len() != 0)
        {
            server.log("--***-- Voltage Channels --***--\n"+report_pvoltest);
        }
        if(report_MB.len() != 0)
        {
            server.log("--***-- Modbus Channels --***--\n"+report_MB);
        }
        if(report_MB_agent.len() != 0)
        {
            server.log("--***-- Agent Modbus Channels --***--\n"+report_MB_agent);
        }
        if(report_PT500_agent.len() != 0)
        {
            server.log("--***-- Agent PT500 Channels --***--\n"+report_PT500_agent);
        }
        if(report_data.len() != 0)
        {
            server.log("--***-- Data Channels --***--\n"+report_data);
        }
        server.log("--***-- End Channels --***--\n");
/*        
        local idx = 0; // default transducer mode
        if(IMP_MODE == PUMP_MODE) // check for pump mode
        {
            if ((idx = makecsv.find("MB")) != null)
            {
                server.log("--***-- Voltages --***--\n"+makecsv.slice(0, idx-1));
            } else
            {
                idx = 0; // didn't find "MB"; couldn't read Modbus
            }
        }
        server.log("--***-- Data Channels --***--\n"+makecsv.slice(idx));
        server.log("--***-- End Channels --***--\n");
*/
            // DEBUG dump csv string
//        server.log("----****----Make CSV:\n"+makecsv);
            // send data to Xively feed
        dataToXively(makecsv);
    }
);  // device.on("tabledata",function(data)

// Prepare the request with a csv payload 
function dataToXively(csv) 
{    
    local XIVELY_API_ENDPOINT = "https://api.xively.com/v2/feeds/"+XIVELY_FEED+".csv";
  local body =  csv;
  local extraHeaders = {
//                        "User-Agent": "xively-Imp-Lib/1.0", 
                        "X-Api-Key": XIVELY_API_KEY,
                        "Authorization": XIVELY_Account_Authorization,
//                        "Content-Type": "text/csv",
//                        "Content-Length": format("%d",body.len())
//                        "Content-Length": body.len()
                        };
  local request = http.put(XIVELY_API_ENDPOINT, extraHeaders, body);
                
    server.log("--> Xively Feed: "+XIVELY_FEED_NAME+
                ", ImpID: "+IMP_DEV_ID+
                ", Network: "+IMP_SSID);
    server.log("--> Package lenth: "+body.len()+
                ", sam per: "+IMP_SAMPLE_PER+
                "s, xmit per: "+IMP_XMIT_PER+"s, "+
                (IMP_MODE?"Pump Mode":"Transducer Mode") );
                
//  server.log("put request: "+request+" extra headers: "+extraHeaders);
  request.sendasync(dataToXivelyResponse);
}   // function dataToXively(csv) 

// This is the completed-request callback function, which logs the
// incoming response's message and status code
function dataToXivelyResponse(response) 
{
    if (response.statuscode == 200)
    {
        return;
    }
        // print message if status code is not 200
    server.log("Status Code Put dataToXively CSV: " + response.statuscode + 
                ", Message: " + (response.body==""?"none":response.body));
}   // function dataToXivelyResponse(response) 

// Get Xively/Imp connection data from a special Xively feed
// called from device.on("metadata", function(data)
function getXivelyFeedsTable()
{
        // This is the feed URL for the Xively Feeds Table
    local url = "https://api.xively.com/v2/feeds/1879147064";
//    local xively_apikey = "rOSourU7osPHSsLzveclcZGjVwhLek0GMhUPVhTfWwsMwY6v";  
    local extraHeaders = {
                        "X-Api-Key": "rOSourU7osPHSsLzveclcZGjVwhLek0GMhUPVhTfWwsMwY6v",
//                        "User-Agent":"xively-Imp-Lib/1.0", 
//                        "Content-Type":"text/csv",
//                        "Authorization": "Basic a25pZ2h0aGF3azprbmlnM3QzOHdr"
                        "Authorization": XIVELY_Account_Authorization,
                        };
        // Set up the get request
    local request = http.get(url, extraHeaders);
//    request.sendasync(processResponseFeeds);
        // Make the request
    local response = request.sendsync();
        // Process the response
    getXivelyFeedsTableResponse(response);
    
}   // function getXivelyFeedsTable()

// This is the completed-request callback function, which logs the
// incoming response's message and status code
function getXivelyFeedsTableResponse(response) 
{
//    server.log("Status Code Xively Feeds: " + response.statuscode + ", Message: " + 
//                (response.body==""?"none":response.body.slice(0,25)+"..."));
                
    // In the Special Xively Feed, under the description meta data field
    // there are a group of lines such as the following.
    // Each line contains a comma delimited fields that identify
    
    // impID, Xively feed name, feed id and feed api key.

//    ImpID,       XivelyName,  XivelyFeed,      XivelyApiKey
//  anyimp, SpecialData,   1879147064, rOSourU7osPHSsLzveclcZGjVwhLek0GMhUPVhTfWwsMwY6v
//  235e9deb6e4936ee, WM235e9,   1932829324, 8HqPPy2ymRbzqZhT2TtdWM5h193oJmf8uQhoSdvtfxc9bAYA
//  23219ab236a7c9ee, WM23219, 343437348, WlnQANSpdLKnerPxm62yhaxVVwEojtBjQT0Okru4zt7WDKwh
    
    // The goal here is to search through the lines with the imp ID (IMP_DEV_ID),
    // find the line that starts with the imp ID, isolate the line, and
    // split the line into the components.
    
    // take apart the response body and find Xively info
    // First json decode the line. The data we are looking for
    // is in the data.description string object
    local data = http.jsondecode(response.body);
        // match the line with the Imp DeviceID
        // define a regex to look for the dev ID at the beginning
        // of a line
//    local match = @"("+IMP_DEV_ID+@".*\n)"; // regex string defined
        // Removed the \n and the expression started working again
//    local match = @"("+IMP_DEV_ID+@".*)"; // regex string defined
        // does not match \n correctly
//    local match = "("+IMP_DEV_ID+@".*\n)"; // regex string defined
    local match = "("+IMP_DEV_ID+@".*)"; // regex string defined
    server.log("-- match string: "+match);
        // compile the regex
    local ex = regexp(match);
        // apply the regular expression
    local result = ex.capture(data.description);
    local xivelyInfo; // array for Xively name, feed and api key
        // xivelyInfo[0] = ImpID
        // xivelyInfo[1] = XivelyName
        // xivelyInfo[2] = XivelyFeed
        // xivelyInfo[3] = XivelyApiKey
    
        // if the regular expression returns null, there is no match
    if (result == null)
    {
        server.log("--result == null: no match in: "+data.description);
        return;
    }
            // if here, regular expression matched
            // Next, grab the line with the imp ID and 
            // split out the Xively feed information
            
            // result contains an array of tables with
            // the begin and end position
            // values for the match
            
//    server.log("search results for Imp-Xively Table: "+data.description.slice(result[0].begin,result[0].end));
        // slice gets the string with imp ID
        // split breaks the string apart by commas
        // This gives an array with the following elements:
        // impID,           Xively feed name,   feed id and feed api key.
        // 235c87eb6e4936ee, PowerTest01,       2107508645, iKZLtPhqDBWssrASLyNyot8n1pUc5pshqOZlCgqlip0WH0je
    xivelyInfo = split(data.description.slice(result[0].begin,result[0].end),", ");

//    xivelyInfo[0] - Imp ID
//    xivelyInfo[1] - Name of Xively Feed
//    xivelyInfo[2] - Feed ID
//    xivelyInfo[3] - API Key
//    server.log("Imp-Xively Table Info: Imp ID: "+xivelyInfo[0]+" Feed Name: "+xivelyInfo[1]+
//                " Feed ID: "+xivelyInfo[2]+" API key: "+xivelyInfo[3]);
                
    server.log("Imp-Xively Table Info: Imp ID: "+xivelyInfo[0]+" Feed Name: "+xivelyInfo[1]+
                " Feed ID: "+xivelyInfo[2]);
        
        // strip gets rid of whitespace at the beginning and end of the string - needed 
        // to get rid of new line
    IMP_DEV_ID  = strip(xivelyInfo[X_IMP_DEV_ID]);
    XIVELY_FEED_NAME = strip(xivelyInfo[X_XIVELY_FEED_NAME]);
    XIVELY_FEED = strip(xivelyInfo[X_XIVELY_FEED]);
    XIVELY_API_KEY = strip(xivelyInfo[X_XIVELY_API_KEY]);
    
    try // see if any of these are in the array
    {
        IMP_SAMPLE_PER = strip(xivelyInfo[X_IMP_SAMPLE_PER]).tofloat();
        IMP_XMIT_PER = strip(xivelyInfo[X_IMP_XMIT_PER]).tofloat();
        IMP_MODE = strip(xivelyInfo[X_IMP_MODE]).tointeger(); // MOTOR or TRANSDUCER mode
        
        IMP_ANALOG1_THRESHOLD = strip(xivelyInfo[X_IMP_ANALOG1_THRESHOLD]).tofloat();
        IMP_ANALOG1_RANGE = strip(xivelyInfo[X_IMP_ANALOG1_RANGE]).tofloat();
        
    }  catch (e) 
    {
        // We don't care if it fails because default values will be there
    }

        // These should be either default values or set in the code above  
/*
    server.log("Imp samples period: "+IMP_SAMPLE_PER);
    server.log("Imp transmit period: "+IMP_XMIT_PER);
    server.log("Operating mode: "+(IMP_MODE?"Pump Mode":"Transducer Mode"));
    server.log("Analog1 threhold: "+IMP_ANALOG1_THRESHOLD);
    server.log("Analog1 range: "+IMP_ANALOG1_RANGE);
*/    
    local vars = { "IMP_SAMPLE_PER" : IMP_SAMPLE_PER,
                    "IMP_XMIT_PER" : IMP_XMIT_PER,
                    "IMP_MODE" : IMP_MODE,
                    "IMP_ANALOG1_THRESHOLD" : IMP_ANALOG1_THRESHOLD,
                    "IMP_ANALOG1_RANGE" : IMP_ANALOG1_RANGE,
                };
                
        // Send information to device
        device.send("impControlVariables", vars );

        // in order to use device.send, the device must not
        // be asleep. If asleep, it never receives the send.
        // To make sure device is awake, use the device.onconnect
        // method to send the device.send request
    device.onconnect(function() 
    {
        // Send information to device
        device.send("impControlVariables", vars );
        server.log("######## Device connected to agent - impControlVariables");
    });

        // Since device.onconnect stays active and executes with
        // each connect, it is necessary to reset it at disconnect time.
        // At disconnect time, turn off the device.onconnect procedure
        // so the device.send(newsetpoint, num) doesn't keep running
    device.ondisconnect(function()
    {
        device.onconnect(function(){});
    });
}   // function getXivelyFeedsTableResponse(response) 

// handle a trigger from Xively
function requestHandler(request, response)
{
//    server.log("++++++++++++++received Xively trigger++++++++++++++++");
    // if it was, send the value of it to the device
    // device.send("cmd1 found: ", request.query["cmd1"]);
    local num = 9;
    local data;

    if (request.query.cmd1.find("go", 1) )
    {
            // decode the url
        data = http.urldecode(request.body);
        local datajson;
        // now decode json to make an object
        datajson = http.jsondecode(data.body);
        // get the value of the new setting from the object
        num = datajson.triggering_datastream.value.value;
        
    // **** DEBUG ****//
    // If there is no connect/disconnect, use this    
        device.send("newsetpoint", num);
        server.log("+++++ Trigger Received - Quarts per day: "+num+" +++++");
        // in order to use device.send, the device must not
        // be asleep. If asleep, it never receives the send.
        // To make sure device is awake, use the device.onconnect
        // method to send the device.send request
        device.onconnect(function() 
        {
            device.send("newsetpoint", num);
            server.log("######## Device connected to agent - newsetpoint");
        });

        // Since device.onconnect stays active and executes with
        // each connect, it is necessary to reset it at disconnect time.
        // At disconnect time, turn off the device.onconnect procedure
        // so the device.send(newsetpoint, num) doesn't keep running
        device.ondisconnect(function()
        {
            device.onconnect(function(){});
        });
    } else
    {   // assume message in cmd1 for modem string
        device.send("modem_write", request.query.cmd1);
        server.log("cmd1 found in request.query: "+request.query.cmd1);
    }

try
    {
        // send a response back to whoever made the request
        response.send(200, "OK"); // "200: OK" is standard return message
    }
    catch (ex)
    {
        response.send(500, ("Agent Error: " + ex)); // Send 500 response if error occured
    }
    
}   // function requestHandler(request, response)

    // set up the http request handler
    // for Xively set qpd trigger
http.onrequest(requestHandler);

server.log("---AGENT CODE END---");
    
